**Современные технологии серверной разработки**
## Лабораторная работа №2 (6 ч)

**Тема:** Разработка сетевого приложения на Java с использованием протоколов TCP и UDP.

**Цель работы:** освоить принципы разработки сетевых приложений на языке Java с использованием протоколов TCP и UDP.

### Теоретические сведения

#### Протоколы TCP и UDP
Протоколы TCP (Transmission Control Protocol) и UDP (User Datagram Protocol) - это транспортные протоколы для передачи данных между компьютерами и другими устройствами. Они работают на транспортном уровне модели OSI, обеспечивая доставку данных от одного приложения к другому.

Протокол TCP обеспечивает надежную передачу данных: он устанавливает соединение, контролирует доставку пакетов, обеспечивает порядок следования и повторную отправку потерянных данных.

Протокол UDP предоставляет более простой и быстрый способ передачи данных без установления соединения, контроля доставки или порядка. В основном он используется для приложений, где важна скорость, а не надежность, например, для потокового видео или онлайн-игр.

TCP и UDP являются базовыми протоколами для написания сетевых программ. В большинстве языков программирования существуют встроенные средства и библиотеки для работы с этими протоколами.

Поскольку множество программ на одном устройстве могут использовать сеть одновременно, необходимо различать для какого именно приложения предназначены полученные данные. Для идентификации конкретного приложения или службы на устройстве используется сетевой порт. IP-адрес указывает на устройство в сети, а порт - на конкретный процесс или службу на этом устройстве. Например, веб-сервер обычно использует порт 80 (HTTP) или 443 (HTTPS).

Единицей передачи данных в этих протоколах является байт. Протокол TCP воспринимает данные как непрерывный поток, который разбивается на сегменты. UDP оперирует датаграммами, каждая из которых представляет собой независимый блок данных, размером в несколько сотен или тысяч байт, который передается целиком. Независимо от способа упаковки, базовой единицей обработки информации всё равно остается байт.

#### Сокеты
Сокет - это программный интерфейс, который позволяет программам обмениваться данными по сети. Он выступает как «конечная точка» сетевого соединения, например, с одной стороны сервер, с другой - клиент.

В  Java сокеты - это объекты из пакета `java.net`, которые инкапсулируют всю низкоуровневую работу с сетью и предоставляют удобные методы для отправки и получения данных по сети.

Для создания сетевого приложения в Java используются разные типы сокетов в зависимости от протокола:
- для TCP:
	- `ServerSocket` - для прослушивания входящих подключений на сервере
	- `Socket` - клиентский сокет для установления соединения и обмена данными
	- данные передаются через потоки ввода/вывода (`InputStream` / `OutputStream`)
- для UDP:
	- `DatagramSocket` - для отправки и приёма пакетов
	- `DatagramPacket` - контейнер для данных и адреса назначения/источника
	- данные передаются в виде отдельных пакетов

#### Пул потоков
Когда сервер обслуживает множество клиентов, он обычно создаёт отдельный поток для каждого подключения. Однако создание и уничтожение потоков - операция затратная по времени и памяти.

Пул потоков (thread pool) - это механизм, при котором заранее создаётся ограниченное количество потоков, и они многократно используются для выполнения задач. Вместо того чтобы каждый раз создавать новый поток, сервер помещает задачу в очередь, а свободный поток из пула берёт её на выполнение.

В Java пул потоков реализован через интерфейс `ExecutorService` и фабричные методы класса `Executors` для создания пула потоков:
- `newFixedThreadPool(n)` - фиксированное число потоков
- `newCachedThreadPool()` - динамический пул, создаёт новые потоки при необходимости
- `newSingleThreadExecutor()` - один поток для последовательной обработки

Размер пула потоков подбирается экспериментально, исходя из числа ядер процессора и характера задач.

Пример использования пула потоков с TCP-сокетом:

```Java
import java.io.*;  
import java.net.ServerSocket;  
import java.net.Socket;  
import java.util.concurrent.ExecutorService;  
import java.util.concurrent.Executors;  
  
public class TCPServer {  
    private final ServerSocket socket;  
    private final INetController controller;  
    private volatile boolean running = false;  
  
    /**  
     *     
	 * @param port Номер сетевого порта  
     * @param controller Контроллер для обработки запроса  
     * @throws IOException  
     */    
	 public TCPServer(int port, INetController controller) throws IOException {  
        socket = new ServerSocket(port);  
        // Устанавливаем таймаут ожидания данных на потоке ввода,  
        // чтобы сервер не "завис" при отсутствии клиентов
		socket.setSoTimeout(3_000);  
  
        this.controller = controller;  
    }  
  
    /**  
     * Запуск TCP-сервера     
	 * @param thread_pool_size Размер пула потоков  
     */    
	 public void run(int thread_pool_size) {  
        // Создаем пул потоков  
        ExecutorService pool = Executors.newFixedThreadPool(thread_pool_size);  
  
        running = true;  
  
        do {  
            try {  
                // Ожидаем новое подключение (клиента)  
                Socket clientSocket = socket.accept();  
                // Работаем с новым подключением в потоке  
                pool.execute(new ClientHandler(clientSocket, controller));  
            } catch (IOException ignored) {}  
        } while (running);  
  
        // Останавливаем пул потоков  
        pool.shutdown();  
    }  
  
    /**  
     * Класс для работы с клиентом     
	 */    
	 private static class ClientHandler implements Runnable {  
        private final Socket socket;  
        private final INetController controller;  
  
        /**  
         *         
		 * @param socket Клиентский сокет  
         * @param controller Контроллер для обработки запроса  
         */        
		 ClientHandler(Socket socket, INetController controller) {  
            this.socket = socket;  
            this.controller = controller;  
        }  
  
        @Override  
        public void run() {  
            // Создаем объекты для работы с потоками ввода/вывода  
            try (BufferedReader in = new BufferedReader(  
                    new InputStreamReader(socket.getInputStream()));  
                    PrintWriter out = new PrintWriter(socket.getOutputStream(), true)) {  
                // Получаем данные от клиента  
                String request = in.readLine();  
                // Отправляем их в контроллер для обработки и  
                // Получаем ответ                
				String response = controller.handleRequest(request);  
  
                // Отправляем данные клиенту  
                out.println(response);  
            } catch (IOException ignored) {}  
        }  
    }  
}
```

Обратите внимание, что обработка данных от клиента выполняется отдельным классом, т.е. класс `TCPServer` отвечает только за прием новых подключений и работу с ними, а обработку данных от клиентов делегирует классу, реализующему интерфейс INetController, объект которого передается через конструктор.

#### Организация структуры сетевого приложения
Механизм сетевого взаимодействия необходимо внедрять таким образом, чтобы в процессе внедрения Вам не пришлось менять бизнес-логику приложения. Сокеты - это один из способов взаимодействия с Вашим приложением (как, например, и UI), поэтому работу с ними необходимо выделить в отдельный слой. Например:

<p align="center">
  <img src="./СТСервР-L2.png" alt="СТСервР-L2.png" width="50%">
</p>

Здесь `Networking Layer` - это слой сетевого взаимодействия.

### Задание

Разработать сетевое приложение с архитектурой клиент-сервер на Java с использованием протоколов TCP и UDP. За основу для сервера взять приложение, разработанное в л.р. №1, и добавить в него механизм сетевого взаимодействия. 

Сервер должен принимать запросы от клиентов на выполнение CRUD и др. операций, обрабатывать их и возвращать ответ. При этом должна быть возможность одновременной обработки запросов от нескольких клиентов.

Клиент подключается к серверу, отправляет запросы и получает ответ. Тип UI на выбор (консольный, графический).

Должна быть возможность задавать номер сетевого порта, адрес сервера, количество используемых потоков и прочие параметры в конфигурационных файлах.

На защите продемонстрировать работу с нескольких устройств.

**Отчёт по лабораторной работе должен содержать:**
1. Цель и задачи работы.
2. Описание формата данных, передаваемых по сети.
3. Список реализованных классов для сетевого взаимодействия и их описание.
4. Содержимое конфигурационного файла и список параметров с описанием. 
5. Скриншоты с результатами работы программы (сервер и клиент).
6. Вывод по выполненной работе.

### Варианты

Протокол:
- TCP - четные варианты
- UDP - нечетные варианты

Формат данных для передачи по сети:
- сериализованные объекты - варианты 1, 4, 7, 10 и т.д.
- JSON - варианты 2, 5, 8, 11 и т.д.
- строка заданного шаблона (разработать самим) - варианты 3, 6, 9, 12 и т.д.
